#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Sistema de Gestión de Inventarios (versión con persistencia en archivos y manejo robusto de excepciones)

Características clave:
- Persistencia en archivo de texto (JSON) "inventario.txt" por defecto.
- Carga automática al iniciar; crea el archivo si no existe.
- Manejo de excepciones detallado (FileNotFoundError, PermissionError, JSONDecodeError, OSError, etc.).
- Escritura atómica mediante archivo temporal + os.replace para evitar archivos corruptos.
- Respaldo automático del archivo corrupto (*.bak-YYYYmmdd-HHMMSS) y reconstrucción segura.
- Interfaz de consola con mensajes claros de éxito/fracaso de operaciones de archivo.
- Pruebas básicas ejecutables con bandera --pruebas.

Autor: (James Chimbo)
Fecha: 2025-08-24
"""
from __future__ import annotations

import json
import os
import sys
import tempfile
from dataclasses import dataclass, asdict
from datetime import datetime
from typing import Dict, List, Optional


# ==============================
# Modelo de datos
# ==============================
@dataclass
class Producto:
    codigo: str
    nombre: str
    stock: int
    precio: float

    def validar(self) -> None:
        if not self.codigo or not self.codigo.strip():
            raise ValueError("El código no puede estar vacío.")
        if not self.nombre or not self.nombre.strip():
            raise ValueError("El nombre no puede estar vacío.")
        if not isinstance(self.stock, int):
            raise ValueError("El stock debe ser un entero.")
        if self.stock < 0:
            raise ValueError("El stock no puede ser negativo.")
        if not isinstance(self.precio, (int, float)):
            raise ValueError("El precio debe ser numérico.")
        if self.precio < 0:
            raise ValueError("El precio no puede ser negativo.")


# ==============================
# Repositorio con persistencia
# ==============================
class Inventario:
    def __init__(self, ruta_archivo: str = "inventario.txt") -> None:
        self.ruta_archivo = ruta_archivo
        self._items: Dict[str, Producto] = {}
        self._cargar_desde_archivo()

    def agregar_producto(self, producto: Producto) -> bool:
        producto.validar()
        if producto.codigo in self._items:
            raise ValueError(f"Ya existe un producto con código '{producto.codigo}'.")
        self._items[producto.codigo] = producto
        self._guardar_a_archivo()
        return True

    def actualizar_producto(self, codigo: str, *, nombre: Optional[str] = None,
                             stock: Optional[int] = None, precio: Optional[float] = None) -> bool:
        if codigo not in self._items:
            raise KeyError(f"No existe un producto con código '{codigo}'.")
        p = self._items[codigo]
        if nombre is not None and nombre.strip():
            p.nombre = nombre
        if stock is not None:
            if stock < 0:
                raise ValueError("El stock no puede ser negativo.")
            p.stock = stock
        if precio is not None:
            if precio < 0:
                raise ValueError("El precio no puede ser negativo.")
            p.precio = float(precio)
        p.validar()
        self._guardar_a_archivo()
        return True

    def eliminar_producto(self, codigo: str) -> bool:
        if codigo not in self._items:
            raise KeyError(f"No existe un producto con código '{codigo}'.")
        del self._items[codigo]
        self._guardar_a_archivo()
        return True

    def buscar_producto(self, codigo: str) -> Optional[Producto]:
        return self._items.get(codigo)

    def listar_productos(self) -> List[Producto]:
        return list(self._items.values())

    def _cargar_desde_archivo(self) -> None:
        try:
            if not os.path.exists(self.ruta_archivo):
                self._escribir_lista_productos([])
                print(f"[INFO] Archivo '{self.ruta_archivo}' creado (no existía).")
                return

            with open(self.ruta_archivo, 'r', encoding='utf-8') as f:
                contenido = f.read().strip()
                if not contenido:
                    self._items = {}
                    return
                data = json.loads(contenido)
                recuperados: Dict[str, Producto] = {}
                for raw in data:
                    prod = Producto(
                        codigo=str(raw['codigo']),
                        nombre=str(raw['nombre']),
                        stock=int(raw['stock']),
                        precio=float(raw['precio'])
                    )
                    prod.validar()
                    recuperados[prod.codigo] = prod
                self._items = recuperados
        except (json.JSONDecodeError, ValueError) as e:
            print(f"[ALERTA] Archivo corrupto: {e}")
            self._respaldar_archivo_corrupto()
            self._escribir_lista_productos([])
            self._items = {}
        except PermissionError:
            print(f"[ERROR] Permiso denegado al leer '{self.ruta_archivo}'.")
            self._items = {}

    def _guardar_a_archivo(self) -> None:
        data = [asdict(p) for p in self.listar_productos()]
        self._escribir_lista_productos(data)

    def _escribir_lista_productos(self, data_list: List[dict]) -> None:
        carpeta = os.path.dirname(os.path.abspath(self.ruta_archivo)) or '.'
        os.makedirs(carpeta, exist_ok=True)
        fd, temp_path = tempfile.mkstemp(prefix="inventario_", suffix=".tmp", dir=carpeta, text=True)
        try:
            with os.fdopen(fd, 'w', encoding='utf-8') as tmp:
                json.dump(data_list, tmp, ensure_ascii=False, indent=2)
                tmp.flush()
                os.fsync(tmp.fileno())
            os.replace(temp_path, self.ruta_archivo)
        except Exception:
            if os.path.exists(temp_path):
                os.remove(temp_path)
            raise

    def _respaldar_archivo_corrupto(self) -> None:
        ts = datetime.now().strftime('%Y%m%d-%H%M%S')
        backup_path = f"{self.ruta_archivo}.bak-{ts}"
        os.replace(self.ruta_archivo, backup_path)
        print(f"[INFO] Respaldo creado: {backup_path}")


# ==============================
# Interfaz de usuario (consola)
# ==============================
MENU = """
================= Inventario =================
1) Agregar producto
2) Actualizar producto
3) Eliminar producto
4) Buscar producto
5) Listar productos
6) Salir
==============================================
Seleccione una opción: """

def mostrar_producto(p: Producto) -> None:
    print(f"Código: {p.codigo} | Nombre: {p.nombre} | Stock: {p.stock} | Precio: {p.precio:.2f}")

def bucle_principal(ruta_archivo: str = "inventario.txt") -> None:
    inv = Inventario(ruta_archivo=ruta_archivo)
    print("[OK] Inventario listo. Archivo:", inv.ruta_archivo)
    while True:
        opcion = input(MENU).strip()
        if opcion == '1':
            codigo = input("Código: ").strip()
            nombre = input("Nombre: ").strip()
            stock = int(input("Stock: "))
            precio = float(input("Precio: "))
            try:
                inv.agregar_producto(Producto(codigo, nombre, stock, precio))
                print(" Producto agregado y guardado en el archivo correctamente.")
            except Exception as e:
                print(" Error:", e)
        elif opcion == '2':
            codigo = input("Código del producto a actualizar: ").strip()
            nuevo_nombre = input("Nuevo nombre (enter para no cambiar): ").strip()
            nuevo_stock = input("Nuevo stock (enter para no cambiar): ").strip()
            nuevo_precio = input("Nuevo precio (enter para no cambiar): ").strip()
            kwargs = {}
            if nuevo_nombre:
                kwargs['nombre'] = nuevo_nombre
            if nuevo_stock:
                kwargs['stock'] = int(nuevo_stock)
            if nuevo_precio:
                kwargs['precio'] = float(nuevo_precio)
            try:
                inv.actualizar_producto(codigo, **kwargs)
                print(" Producto actualizado.")
            except Exception as e:
                print(" Error:", e)
        elif opcion == '3':
            codigo = input("Código del producto a eliminar: ").strip()
            try:
                inv.eliminar_producto(codigo)
                print(" Producto eliminado.")
            except Exception as e:
                print(" Error:", e)
        elif opcion == '4':
            codigo = input("Código a buscar: ").strip()
            p = inv.buscar_producto(codigo)
            if p:
                mostrar_producto(p)
            else:
                print("ℹ No se encontró el producto.")
        elif opcion == '5':
            productos = inv.listar_productos()
            if not productos:
                print("(Inventario vacío)")
            else:
                for p in productos:
                    mostrar_producto(p)
        elif opcion == '6':
            print("Hasta luego ")
            break
        else:
            print("Opción inválida.")


if __name__ == "__main__":
    ruta = "inventario.txt"
    if len(sys.argv) >= 2:
        ruta = sys.argv[1]
    bucle_principal(ruta)
